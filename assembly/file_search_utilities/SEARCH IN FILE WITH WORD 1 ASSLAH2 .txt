GETSTR MACRO STR
MOV AH,0AH
LEA DX,STR
INT 21H
ENDM   

GETSTR2 MACRO STR
            lea si, filename
            mov ah, 01h     
    char_input:

            int 21h

            cmp al, 0dh      
            je zero_terminator

            mov [si], al
            inc si

            jmp char_input

    zero_terminator:

            mov byte ptr [si], 0 
            xor si ,si 
            xor ax,ax
            xor dx, dx
ENDM 

GETSTR1 MACRO STR
LEA SI , STR
MOV DX , SI
MOV AH, 0AH
INT 21H
ENDM 

PRINTSTR MACRO STR
MOV AH,09H
LEA DX,STR
INT 21H
ENDM
  
PRINTSTR1 MACRO STR

LEA si , STR
ADD si , 2
MOV DX , si 
MOV AH , 09H
INT 21H

ENDM


stacksg segment para stack 
   sb    db       1024 dup('0')
  
stacksg ends

datasg  segment para common 'data'
    ;/-----------------------------------------------print menu--------     
    p1 db 'Please enter name file:',0DH,0AH,'$'
    
    BREAK DB 10, 13,'$'
    PR_2  DB  'Please enter key saerch : ',0DH,0AH,'$'
    PR_3  DB   0DH,0AH,'The key saerch found in this line:) ',0DH,0AH,'$'
    PR_5  DB  'The key saerch NOT found :( ',0DH,0AH,'$'
  
    PR_7  DB  '=========================================  ',0DH,0AH,'$'
    PR_8  DB  '####****THANKS FOR TIME****####  ',0DH,0AH,'$'
    ;/--------------------------------------------------MAIN DATA---------
    word db 80 dup('$'),'$' ;/word  
    line db 80 dup('$'),'$' ;/line  
  
    filename db "TEST.TXT" ;/file name
     filehandle  dw ?
     cot dW 00,'$'
     
     TCOUNT DW ? 
     T2COUNT DW 00 
     
     char        db ?
 

    

datasg  ends

codesg  segment para common 'code'
main    proc    far
assume  ds:datasg,cs:codesg,es:datasg  


        MOV AX,dataSG
        MOV DS,AX
        MOV ES,AX
        
        PRINTSTR p1
        getstr2 filename  
        PRINTSTR BREAK
        PRINTSTR pr_2
        getstr word   
        PRINTSTR BREAK
         PRINTSTR PR_7
         PRINTSTR BREAK
        
        
       ;------------------------- open_file:

            lea dx, filename
            mov ax,3d00h
           int 21h

            mov filehandle, ax  
            XOR AX, AX                    
            MOV COT , 01H
                  
            MOV   TCOUNT,00 
            lea si, line 
            INC SI
            INC SI
            JMP READ       
       
            
            

           

    read_line: 
    
            lea si, line 
            INC SI
            INC SI 
        
            MOV CX,32h ;Word length 
            LOP: 
            MOV [SI],'$'
            INC SI
            LOOP LOP  
      
            
            
            lea si, line 
            INC SI
            INC SI
            
            
            
         READ:
            mov ah, 3Fh     
            mov bx, filehandle
            lea dx, char
            mov cx, 1

            int 21h

            CMP ax, 0       ;EOF
            jZ EO_file

            mov al, char

            cmp al, 0ah     ; line feed
            je LF 
            
            cmp al, 20h       ;SPACE
            je SPAcE
            

            mov [si], al 
       
            inc si 
         
        INC TCOUNT
            

            jmp READ
            
            
    SPAcE: 
        MOV CX, TCOUNT
        MOV   TCOUNT,00
     SPCHEK:
   
        LEA DI , LINE
        ADD  DI , 2  
        LEA  SI , WORD
        ADD  SI , 2  
        
        MOV AL, WORD+1   
        CMP AL , CL 
                
        JNE READ_LINE                    
     
         MOV CH,00
         REPE CMPSB  
         
         JNE READ_LINE          
        JMP PRINT
    
    EO_file:

        LEA DI , LINE
        ADD  DI , 2  
        LEA  SI , WORD
        ADD  SI , 2  
    
        MOV AL, WORD+1     
        MOV CX, TCOUNT  
        CMP AL , CL         
        JNE EXIT                    
     
         MOV CH,00
         REPE CMPSB
         JNE EXIT            
         inc t2count
        PRINTSTR pr_3 
        PRINTSTR BREAK
           XOR AX ,AX
             MOV AH , 2
            MOV DX,COT
            INT 21H
            
         JMP EXIT
   EXIT:         
   
   
                
            cmp t2count, 00h
            jne exit_ne 
            PRINTSTR pr_5
            
            
       exit_ne:
       PRINTSTR pr_8 
       
       
       
             mov bx,filehandle
            mov ah, 3eh
            int 21h               ;CLOSE FILE

            mov ah, 4ch
            int 21h

    LF:     
        MOV CX, TCOUNT
        MOV   TCOUNT,00
        INC COT   
        JMP SPCHEK
            
            
            
    PRINT:    
              PRINTSTR pr_3
              PRINTSTR BREAK
              XOR AX ,AX
             MOV AX , COT
             CALL OUTDEC
          inc t2count  
        PRINTSTR BREAK
        JMP read_line  
        

        
 MAIN ENDP   
 
  OUTDEC PROC
   ; this procedure will display a decimal number
   ; input : AX
   ; output : none

   PUSH BX                        ; push BX onto the STACK
   PUSH CX                        ; push CX onto the STACK
   PUSH DX                        ; push DX onto the STACK

   CMP AX, 0                      ; compare AX with 0
   JGE STARTl                     ; jump to label @START if AX>=0

   PUSH AX                        ; push AX onto the STACK

   MOV AH, 2                      ; set output function
   MOV DL, "-"                    ; set DL=\'-\'
   INT 21H                        ; print the character

   POP AX                         ; pop a value from STACK into AX

   NEG AX                         ; take 2\'s complement of AX

   STARTl:                        ; jump label

   XOR CX, CX                     ; clear CX
   MOV BX, 10                     ; set BX=10

   OUTPUTl:                       ; loop label
     XOR DX, DX                   ; clear DX
     DIV BX                       ; divide AX by BX
     PUSH DX                      ; push DX onto the STACK
     INC CX                       ; increment CX
     OR AX, AX                    ; take OR of Ax with AX
   JNE OUTPUTl                    ; jump to label @OUTPUT if ZF=0

   MOV AH, 2                      ; set output function

   DISPLAYl:                      ; loop label
     POP DX                       ; pop a value from STACK to DX
     OR DL, 30H                   ; convert decimal to ascii code
     INT 21H                      ; print a character
   LOOP DISPLAYl                  ; jump to label @DISPLAY if CX!=0

   POP DX                         ; pop a value from STACK into DX
   POP CX                         ; pop a value from STACK into CX
   POP BX                         ; pop a value from STACK into BX

   RET                            ; return control to the calling procedure
 OUTDEC ENDP



   
end main