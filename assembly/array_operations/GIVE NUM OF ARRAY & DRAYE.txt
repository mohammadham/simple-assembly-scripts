 .MODEL SMALL 
 
 PRINTSTR MACRO STR
MOV AH,09H
LEA DX,STR
INT 21H
ENDM   


GETSTR1 MACRO STR
LEA SI , STR
MOV DX , SI
MOV AH, 0AH
INT 21H
ENDM 

 OUTDEC MACRO
   ; this procedure will display a decimal number
   ; input : AX
   ; output : none

   PUSH BX                        ; push BX onto the STACK
   PUSH CX                        ; push CX onto the STACK
   PUSH DX                        ; push DX onto the STACK

   CMP AX, 0                      ; compare AX with 0
   JGE @START                     ; jump to label @START if AX>=0

   PUSH AX                        ; push AX onto the STACK

   MOV AH, 2                      ; set output function
   MOV DL, "-"                    ; set DL='-'
   INT 21H                        ; print the character

   POP AX                         ; pop a value from STACK into AX

   NEG AX                         ; take 2's complement of AX

   @START:                        ; jump label

   XOR CX, CX                     ; clear CX
   MOV BX, 10                     ; set BX=10

   @OUTPUT:                       ; loop label
     XOR DX, DX                   ; clear DX
     DIV BX                       ; divide AX by BX
     PUSH DX                      ; push DX onto the STACK
     INC CX                       ; increment CX
     OR AX, AX                    ; take OR of Ax with AX
   JNE @OUTPUT                    ; jump to label @OUTPUT if ZF=0

   MOV AH, 2                      ; set output function

   @DISPLAY:                      ; loop label
     POP DX                       ; pop a value from STACK to DX
     OR DL, 30H                   ; convert decimal to ascii code
     INT 21H                      ; print a character
   LOOP @DISPLAY                  ; jump to label @DISPLAY if CX!=0

   POP DX                         ; pop a value from STACK into DX
   POP CX                         ; pop a value from STACK into CX
   POP BX                         ; pop a value from STACK into BX

                            ; return control to the calling procedure
ENDM

GETNUM MACRO STR ;GET POSTIVE NUM
PUSHA     
    mov ax,00   ;RETURN NUMBER IN AX
    ll1:
    GETSTR1 NUMBER
	mov si , 02   
	mov ax,00 
	cmp NUMBER[si],0DH
	jE  @ERROR
	cmp NUMBER[si],'-'
	jNE mosbat
	@ERROR:
	PRINTSTR mass
	
	mov ax , 00
	jmp ll1
	
	mosbat:
	mov bx, 00
	mov bl , NUMBER[si]
	CMP BL , 57
	JG EX1
	CMP BL , 48
	JL EX1
	sub bl , 30h
	add ax, bx
	inc si   
	cmp NUMBER[si], 57
	jg ex1
	cmp NUMBER[si], 48
	jl ex1 
	mov bx , 10
	mul bx
	jmp mosbat 
ex1:                                
  MOV STR , AX   
 POPA                     
ENDM 


INPUTNUM MACRO STR;GIVE 2DIGIT NUMBER STORE IN AX
PUSHA
PRINTSTR MASS2

MOV AH,1
INT 21H  
cmp al , 0dh
jNe CONTINUE
MOV AX , 00
jmp convert

CONTINUE:
cmp al , 2dh
je manfi

;----------------mosbat

SUB AL,30H
MOV AH,0
MOV BL,10
MUL BL

MOV BL,AL

MOV AH,1
INT 21H
cmp al , 0DH  ;-------newl
jne ne
MOV AL,BL
MOV BL,10  
MOV AH,0
DIV BL

jmp convert
ne:
SUB AL,30H
MOV AH,0
ADD AL,BL
jmp convert
;------------------ manfi
manfi:  

MOV AH,1
INT 21H
SUB AL,30H
MOV AH,0
MOV BL,10
MUL BL

MOV BL,AL

MOV AH,1
INT 21H 
cmp al , 0DH  ;-------newl
jne ne1
MOV AL,BL
MOV BL,10 
MOV AH,0
DIV BL 

jmp MANFI2
ne1:

SUB AL,30H
MOV AH,0
ADD AL,BL
MANFI2:
not ax
inc ax

convert: 
;MOV AH,0
MOV STR , AX

POPA 

ENDM

PRINTSTR1 MACRO STR

LEA si , STR
ADD si , 2
MOV DX , si 
MOV AH , 09H
INT 21H
ENDM

 .STACK 100H

 .DATA 
    mass db 13,10,"Enter a unsinged number !! ",0DH,0AH,'ENTER NEW NUMBER POSTIVED :$'
    MASS2 DB "Enter a singed number (-99 : 99) :$"
 
    STRING1_1 DB 'enter THE ARRAY element numberS (MAX=60) :', '$' 
    PROMPT_1  DB  'Enter the Array elements :',0DH,0AH,'$'
    PROMPT_2  DB  'The Array elements are : $'  
    BREAK DB 10, 13,'$'
    ROW_NUM DW 0 ,'$'  
    T    DW 00
    NUMBER db 6 dup('$') 
    ARRAY   DW  60 DUP(0)                      

 .CODE
   MAIN PROC
     MOV AX, @DATA                ; initialize DS
     MOV DS, AX
     
         PRINTSTR STRING1_1 
        
        GETNUM ROW_NUM  
                      
     PRINTSTR BREAK
     ;MOV BX , 00
     MOV BX, ROW_NUM                   ; set BX=10

     LEA DX, PROMPT_1             ; load and display the string PROMPT_1
     MOV AH, 9     
     INT 21H

     LEA SI, ARRAY                ; set SI=offset address of ARRAY

     CALL READ_ARRAY              ; call the procedure READ_ARRAY
     LEA SI, ARRAY
     CALL SORT_ARRAY
     
        ;  MOV BX , 00
     MOV BX, ROW_NUM 
     
     LEA DX, PROMPT_2             ; load and display the string PROMPT_2
     MOV AH, 9                    
     INT 21H
 
     LEA SI, ARRAY                ; set SI=offset address of ARRAY

     CALL PRINT_ARRAY             ; call the procedure PRINT_ARRAY

     MOV AH, 4CH                  ; return control to DOS
     INT 21H
   MAIN ENDP

 ;**************************************************************************;
 ;**************************************************************************;
 ;-------------------------  Procedure Definitions  ------------------------;
 ;**************************************************************************;
 ;**************************************************************************; 
 ;**************************************************************************;
 ;-----------------------------  SORT_ARRAY  -------------------------------;
 ;**************************************************************************;

 SORT_ARRAY PROC
   ; this procedure will sort the array in ascending order
   ; input : SI=offset address of the array
   ;       : ROW_NUM=array size
   ; output : none

   PUSH AX                        ; push AX onto the STACK  
   PUSH BX                        ; push BX onto the STACK
   PUSH CX                        ; push CX onto the STACK
   PUSH DX                        ; push DX onto the STACK
   PUSH DI                        ; push DI onto the STACK
   MOV T ,00 
   MOV DX, 00
   MOV AX, SI                     ; set AX=SI
   MOV CX, ROW_NUM                     ; set CX=BX
   DEC CX                         ; set CX=CX-1

   @OUTER_LOOP:                   ; loop label
     MOV BX, ROW_NUM
     DEC BL                 ; set BX=CX

     MOV SI, AX                   ; set SI=AX
     MOV DI, AX                   ; set DI=AX
     ADD DI ,2                      ; set DI=DI+2
     MOV DX, 00
     @INNER_LOOP:                 ; loop label 
       MOV DX, [SI]               ; set DL=[SI]

       CMP DX, [DI]               ; compare DL with [DI]
       JNG @SKIP_EXCHANGE         ; jump to label @SKIP_EXCHANGE if DL<[DI]

       
       ;XCHG DL, [DI]              ; set DL=[DI], [DI]=DL
       MOV T,DX
       MOV DX,[DI]
       MOV [SI], DX
       MOV DX,T 
       MOV [DI],DX
       
       ;MOV [SI], DX               ; set [SI]=DL

       @SKIP_EXCHANGE:            ; jump label
      ADD SI ,2                    ; set SI=SI+2
      ADD DI ,2                    ; set DI=DI+2

       DEC BX                     ; set BX=BX-1
     JNZ @INNER_LOOP              ; jump to label @INNER_LOOP if BX!=0
   LOOP @OUTER_LOOP               ; jump to label @OUTER_LOOP while CX!=0

   POP DI                         ; pop a value from STACK into DI
   POP DX                         ; pop a value from STACK into DX
   POP CX                         ; pop a value from STACK into CX
   POP BX                         ; pop a value from STACK into BX
   POP AX                         ; pop a value from STACK into AX

   RET                            ; return control to the calling procedure
 SORT_ARRAY ENDP

 ;**************************************************************************;
 ;-----------------------------  READ_ARRAY  -------------------------------;
 ;**************************************************************************;

 READ_ARRAY PROC
   ; this procedure will read the elements for an array
   ; input : SI=offset address of the array
   ;       : BX=size of the array
   ; output : none

   PUSH AX                        ; push AX onto the STACK
   PUSH CX                        ; push CX onto the STACK
   PUSH DX                        ; push DX onto the STACK

   MOV CX, ROW_NUM                     ; set CX=BX

   @READ_ARRAY:                   ; loop label
    INPUTNUM T                  ; call the procedure INDEC
     MOV AX , T
     MOV [SI], AX                ; set [SI]=AX
     ADD SI, 2                    ; set SI=SI+2
   PRINTSTR BREAK
   ;  MOV DL, 0AH                  ; line feed
   ;  MOV AH, 2                    ; set output function
    ; INT 21H                      ; print a character
   LOOP @READ_ARRAY               ; jump to label @READ_ARRAY while CX!=0

   POP DX                         ; pop a value from STACK into DX
   POP CX                         ; pop a value from STACK into CX
   POP AX                         ; pop a value from STACK into AX

   RET                            ; return control to the calling procedure
 READ_ARRAY ENDP

 ;**************************************************************************;
 ;-----------------------------  PRINT_ARRAY  ------------------------------;
 ;**************************************************************************;

 PRINT_ARRAY PROC
   ; this procedure will print the elements of a given array
   ; input : SI=offset address of the array
   ;       : BX=size of the array
   ; output : none

   PUSH AX                        ; push AX onto the STACK   
   PUSH CX                        ; push CX onto the STACK
   PUSH DX                        ; push DX onto the STACK

   MOV CX, BX                     ; set CX=BX

   @PRINT_ARRAY:                  ; loop label
     MOV AX, [SI]                 ; set AX=AX+[SI]

        OUTDEC                  ; call the procedure OUTDEC

     MOV AH, 2                    ; set output function
     MOV DL, 20H                  ; set DL=20H
     INT 21H                      ; print a character

     ADD SI, 2                    ; set SI=SI+2
   LOOP @PRINT_ARRAY              ; jump to label @PRINT_ARRAY while CX!=0

   POP DX                         ; pop a value from STACK into DX
   POP CX                         ; pop a value from STACK into CX
   POP AX                         ; pop a value from STACK into AX

   RET                            ; return control to the calling procedure
 PRINT_ARRAY ENDP




 ;**************************************************************************;
 ;--------------------------------------------------------------------------;
 ;**************************************************************************;

 END MAIN

 ;**************************************************************************;
 ;**************************************************************************;
 ;------------------------------  THE END  ---------------------------------;
 ;**************************************************************************;
 ;**************************************************************************;